options:
    soulboundText: "&9Soulbound"

function getNumberTag(i: item, tag: text) :: number:
    return double tag {_tag} of custom nbt of {_i}

function getBooleanTag(i: item, tag: text) :: boolean:
    return boolean tag {_tag} of custom nbt of {_i}

function getTimespanTag(i: item, tag: text) :: timespan:
    set {_tag} to double tag {_tag} of custom nbt of {_i}
    return "%{_tag}% seconds" parsed as timespan

function getStringTag(i: item, tag: text) :: string:
    return string tag {_tag} of custom nbt of {_i}

function getIDFromLore() :: text:
    set {_lore} to line 5 of lore of {_i}
    return last element of ({_lore} split at "ID: ")

function isSoulbound(i: item) :: boolean:
    set {_lore::*} to lore of {_i}
    loop {_lore::*}:
        if loop-value contains {@soulboundText}:
            return true
    return false

function isClassGear(i: item) :: boolean:
    set {_lore::*} to lore of {_i}
    loop {_lore::*}:
        if loop-value contains "ID: ":
            return true
    return false

function isCorrectClass(p: player, class: text) :: boolean:
    if {_p} has permission {_class}:
        return true
    else:
        return false

function isCorrectGear(p: player, usedGear: item, classItems: texts, verbose: boolean = true) :: boolean:
    set {_item_type} to string tag "itemType" of custom nbt of {_usedGear}
    loop {_classItems::*}:
        if {_item_type} is loop-value:
            return true
    if {_verbose} is true:
        send "&7You've only been trained to use &5%{_classItems::*}%!" to {_p}
    return false

function isOnCooldown(p: player, usedGear: item, cooldownTag: text = "isOnCooldown") :: boolean:
    if getBooleanTag({_usedGear}, {_cooldownTag}) is true:
        if string tag "itemType" of custom nbt of {_usedGear} is "slingshot":
            send action bar "&7Reloading..." to {_p}
        else:
            send action bar "&7Recharging..." to {_p}
        play sound "block.note_block.bass" with pitch 0.5 to {_p}
        return true
    else:
        return false

function createClassItem(i: item, itemName: text, loreText: text, counter: text, cooldown: number) :: item:
    set {_id} to random uuid
    set {_classItem} to 1 of unbreakable {_i} named {_itemName} with lore {_loreText}
    set line 2 of lore of {_classItem} to "&7Cooldown: %{_cooldown}% seconds"
    set line 3 of lore of {_classItem} to "%{_counter}%: 0"
    set line 4 of lore of {_classItem} to {@soulboundText}
    set line 5 of lore of {_classItem} to "&8ID: %{_id}%"
    return {_classItem}

function updateKills(i: item) :: item:
    set {_kills} to getNumberTag({_i}, "kills")
    # set {_newKills} to ({_kills} + 1)
    set {_newKills} to ({_kills} + 250)
    set double tag "kills" of custom nbt of {_i} to {_newKills}
    set line 3 of lore of {_i} to "&cKills: %{_newKills}%"
    return {_i}

function addEnchants(p: player, i: item, enchants: enchantment types) :: item:
    send "&2Your %name of {_i}% &2learns from its battles!" to {_p}
    loop {_enchants::*}:
        enchant {_i} with loop-value
    return {_i}

function applyBuffs(t: entity, effects: object):
    # Takes in effects, which must have the buffs key at the top level
    loop compound list tag "buffs" of {_effects}:
        set {_type} to string tag "type" of loop-value
        set {_type} to {_type} parsed as potion effect type
        set {_str} to int tag "strength" of loop-value
        set {_dur} to int tag "duration" of loop-value
        set {_dur} to "%{_dur}% seconds" parsed as timespan
        apply a potion effect of {_type} of tier {_str} to {_t} for {_dur}

function applyDebuffs(t: entity, effects: object):
    # Takes in effects, which must have the debuffs key at the top level
    loop compound list tag "debuffs" of {_effects}:
        set {_type} to string tag "type" of loop-value
        set {_type} to {_type} parsed as potion effect type
        set {_str} to int tag "strength" of loop-value
        set {_dur} to int tag "duration" of loop-value
        set {_dur} to "%{_dur}% seconds" parsed as timespan
        apply a potion effect of {_type} of tier {_str} to {_t} for {_dur}

function applyEffects(t: entity, effects: object, type: text = ""):
    # Applies buffs and/or debuffs based on type parameter
    switch {_type}:
        case "buffs":
            applyBuffs({_t}, {_effects})
        case "debuffs":
            applyDebuffs({_t}, {_effects})
        default:
            applyBuffs({_t}, {_effects})
            applyDebuffs({_t}, {_effects})

# Prevent Enchanting Table use
on enchant prepare:
    if isClassGear(event-item) is true:
        send "&7You cannot find the words to enchant %name of event-item%&7..." to player
        wait 1 tick
        close player's inventory

# Prevent Anvil use
on inventory click:
    if event-inventory is an anvil inventory:
        if index of event-slot is 2:
            set {_i} to slot 2 of event-inventory
            set {_originalName} to name of slot 0 of event-inventory
            if isClassGear({_i}) is true:
                cancel event
                wait 1 tick
                close player's inventory
                send "&7You can't find the will to modify your %{_originalName}%&7..." to player

on drop:
    if isSoulbound(event-item) is true:
        cancel event
        send action bar "&9This item is bound to your soul!" to player

# Keep the item on death
on death of player:
    loop items in victim's inventory:
        if isSoulbound(loop-item) is true:
            add loop-item to {soulbound.drops::%victim's uuid%::*}
            remove loop-item from drops

# Give the items back when they respawn
on respawn:
    if {soulbound.drops::%player's uuid%::*} is set:
        loop {soulbound.drops::%player's uuid%::*}:
            give loop-value to player
        delete {soulbound.drops::%player's uuid%::*}
        send "&7Your %{@soulboundText}% &7items return to you..." to player

# Special Sign Logic
on sign change:
    loop 4 times:
        if line loop-number contains "&":
            set line loop-number to colored line loop-number

on rightclick on mangrove sign:
    set {_sign_behavior} to string tag "components;minecraft:custom_data;BlockEntityTag;server_modification_sign" of nbt of event-block

    if {_sign_behavior} is not set:
        broadcast "Debug: Sign has no special behavior."
        stop

    cancel event
    if {_sign_behavior} is "difficulty_selection":
        set {_chest} to chest inventory with 3 rows named "&eSelect Dungeon Difficulty"
        set slot 11 of {_chest} to poppy named "&6Normal" with lore "&7The intended experience."
        set slot 15 of {_chest} to wither rose named "&cQuite Difficult" with lore "&7For true gamers only."
        open {_chest} to player

    if {_sign_behavior} is "class_selection":
        set {_chest} to chest inventory with 3 rows named "&eSelect Class"
        set slot 11 of {_chest} to wooden axe named "&cBarbarian" with lore "&7Slow warrior with a powerful axe that heals on hit."
        set slot 12 of {_chest} to lead named "&eRanger" with lore "&7Slingshot expert with multiple types of ammo."
        set slot 13 of {_chest} to black candle named "&8Blackmage" with lore "&7Evil(?) mage wielding wither skull and life drain spells."
        set slot 14 of {_chest} to bow named "&dPriestess" with lore "&7Supports allies with a healing bow, and chases enemies with an Iron Golem and Wolf summons."
        set slot 15 of {_chest} to iron sword named "&9Assassin" with lore "&7Blinks behind enemies to deliver critical hits, then vanishes just as quickly."
        open {_chest} to player

on inventory click:
    if name of current inventory is "&eSelect Dungeon Difficulty":
        cancel event
        if event-item is poppy named "&6Normal":
            set {dungeon::difficulty} to "normal"
            broadcast "The dungeon stirs to life..."
        else if event-item is wither_rose named "&cQuite Difficult":
            set {dungeon::difficulty} to "hard"
            broadcast "The monsters in the dungeon have been listening to Hurly... Brace yourself."
        close player's inventory

    if name of current inventory is "&eSelect Class":
        cancel event
        if event-item is wooden axe named "&cBarbarian":
            clear player's inventory
            initializeBarbarianClass(player)
        else if event-item is lead named "&eRanger":
            clear player's inventory
            initializeRangerClass(player)
        else if event-item is black candle named "&8Blackmage":
            clear player's inventory
            initializeBlackmageClass(player)
        else if event-item is bow named "&dPriestess":
            clear player's inventory
            initializePriestessClass(player)
        else if event-item is iron sword named "&9Assassin":
            clear player's inventory
            initializeAssassinClass(player)
        close player's inventory

command /adminGiveDifficultySign:
    permission: op
    trigger:
        set {_sign} to 1 of mangrove_sign named "&eDungeon Difficulty Selection" with lore "&7Right click to select dungeon difficulty."
        set string tag "BlockEntityTag;server_modification_sign" of custom nbt of {_sign} to "difficulty_selection"
        give player {_sign}

command /adminGiveClassSign:
    permission: op
    trigger:
        set {_sign} to 1 of mangrove_sign named "&eClass Selection" with lore "&7Right click to select a class."
        set string tag "BlockEntityTag;server_modification_sign" of custom nbt of {_sign} to "class_selection"
        give player {_sign}

command /adminGiveClass <text>:
    permission: op
    trigger:
        if arg-1 is "barbarian":
            initializeBarbarianClass(player)
        else if arg-1 is "ranger":
            initializeRangerClass(player)
        else if arg-1 is "blackmage":
            initializeBlackmageClass(player)
        else if arg-1 is "priestess":
            initializePriestessClass(player)
        else if arg-1 is "assassin":
            initializeAssassinClass(player)
        else:
            send "&cUnknown class: %arg-1%" to player