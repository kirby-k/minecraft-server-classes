options:
    soulboundText: "&9Soulbound"

function getNumberTag(i: item, tag: text) :: number:
    return double tag {_tag} of custom nbt of {_i}

function getBooleanTag(i: item, tag: text) :: boolean:
    return boolean tag {_tag} of custom nbt of {_i}

function getTimespanTag(i: item, tag: text) :: timespan:
    set {_tag} to double tag {_tag} of custom nbt of {_i}
    return "%{_tag}% seconds" parsed as timespan

function getStringTag(i: item, tag: text) :: string:
    return string tag {_tag} of custom nbt of {_i}

function getIDFromLore() :: text:
    set {_lore} to line 5 of lore of {_i}
    return last element of ({_lore} split at "ID: ")

function isSoulbound(i: item) :: boolean:
    set {_lore::*} to lore of {_i}
    loop {_lore::*}:
        if loop-value contains {@soulboundText}:
            return true
    return false

function isClassGear(i: item) :: boolean:
    set {_lore::*} to lore of {_i}
    loop {_lore::*}:
        if loop-value contains "ID: ":
            return true
    return false

function isCorrectClass(p: player, class: text) :: boolean:
    if {_p} has permission {_class}:
        return true
    else:
        return false

function isCorrectGear(p: player, usedGear: item, classItems: texts, verbose: boolean = true) :: boolean:
    set {_item_type} to string tag "itemType" of custom nbt of {_usedGear}
    loop {_classItems::*}:
        if {_item_type} is loop-value:
            return true
    if {_verbose} is true:
        send "&7You've only been trained to use &5%{_classItems::*}%!" to {_p}
    return false

function isOnCooldown(p: player, usedGear: item, cooldownTag: text = "isOnCooldown") :: boolean:
    if getBooleanTag({_usedGear}, {_cooldownTag}) is true:
        if string tag "itemType" of custom nbt of {_usedGear} is "slingshot":
            send action bar "&7Reloading..." to {_p}
        else:
            send action bar "&7Recharging..." to {_p}
        play sound "block.note_block.bass" with pitch 0.5 to {_p}
        return true
    else:
        return false

function createClassItem(i: item, itemName: text, loreText: text, counter: text, cooldown: number) :: item:
    set {_id} to random uuid
    set {_classItem} to 1 of unbreakable {_i} named {_itemName} with lore {_loreText}
    set line 2 of lore of {_classItem} to "&7Cooldown: %{_cooldown}% seconds"
    set line 3 of lore of {_classItem} to "%{_counter}%: 0"
    set line 4 of lore of {_classItem} to {@soulboundText}
    set line 5 of lore of {_classItem} to "&8ID: %{_id}%"
    return {_classItem}

function updateKills(i: item) :: item:
    set {_kills} to getNumberTag({_i}, "kills")
    # set {_newKills} to ({_kills} + 1)
    set {_newKills} to ({_kills} + 250)
    set double tag "kills" of custom nbt of {_i} to {_newKills}
    set line 3 of lore of {_i} to "&cKills: %{_newKills}%"
    return {_i}

function addEnchants(p: player, i: item, enchants: enchantment types) :: item:
    send "&2Your %name of {_i}% &2learns from its battles!" to {_p}
    loop {_enchants::*}:
        enchant {_i} with loop-value
    return {_i}

function applyBuffs(t: entity, effects: object):
    # Takes in effects, which must have the buffs key at the top level
    loop compound list tag "buffs" of {_effects}:
        set {_type} to string tag "type" of loop-value
        set {_type} to {_type} parsed as potion effect type
        set {_str} to int tag "strength" of loop-value
        set {_dur} to int tag "duration" of loop-value
        set {_dur} to "%{_dur}% seconds" parsed as timespan
        apply a potion effect of {_type} of tier {_str} to {_t} for {_dur}

function applyDebuffs(t: entity, effects: object):
    # Takes in effects, which must have the debuffs key at the top level
    loop compound list tag "debuffs" of {_effects}:
        set {_type} to string tag "type" of loop-value
        set {_type} to {_type} parsed as potion effect type
        set {_str} to int tag "strength" of loop-value
        set {_dur} to int tag "duration" of loop-value
        set {_dur} to "%{_dur}% seconds" parsed as timespan
        apply a potion effect of {_type} of tier {_str} to {_t} for {_dur}

function applyEffects(t: entity, effects: object, type: text = ""):
    # Applies buffs and/or debuffs based on type parameter
    switch {_type}:
        case "buffs":
            applyBuffs({_t}, {_effects})
        case "debuffs":
            applyDebuffs({_t}, {_effects})
        default:
            applyBuffs({_t}, {_effects})
            applyDebuffs({_t}, {_effects})

# Prevent Enchanting Table use
on enchant prepare:
    if isClassGear(event-item) is true:
        send "&7You cannot find the words to enchant %name of event-item%&7..." to player
        wait 1 tick
        close player's inventory

# Prevent Anvil use
on inventory click:
    if event-inventory is an anvil inventory:
        if index of event-slot is 2:
            set {_i} to slot 2 of event-inventory
            set {_originalName} to name of slot 0 of event-inventory
            if isClassGear({_i}) is true:
                cancel event
                wait 1 tick
                close player's inventory
                send "&7You can't find the will to modify your %{_originalName}%&7..." to player

on drop:
    if isSoulbound(event-item) is true:
        cancel event
        send action bar "&9This item is bound to your soul!" to player

# Keep the item on death
on death of player:
    loop items in victim's inventory:
        if isSoulbound(loop-item) is true:
            add loop-item to {soulbound.drops::%victim's uuid%::*}
            remove loop-item from drops

# Give the items back when they respawn
on respawn:
    if {soulbound.drops::%player's uuid%::*} is set:
        loop {soulbound.drops::%player's uuid%::*}:
            give loop-value to player
        delete {soulbound.drops::%player's uuid%::*}
        send "&7Your %{@soulboundText}% &7items return to you..." to player
